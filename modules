/*
Containers can be extracted from different sources
https://github.com/nf-core/tools/issues/1291
conda: https://www.nextflow.io/docs/latest/conda.html
singularity: https://depot.galaxyproject.org/singularity/
docker: https://quay.io/organization/biocontainers
*/

/**************************************************************************************************************************************************************
* fastQC
**************************************************************************************************************************************************************/

process fastqc {	
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/fastqc",
        mode: params.publish_dir_mode
	
	//use container
    conda (params.enable_conda ? "bioconda::fastqc" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/fastqc%3A0.12.1--hdfd78af_0"
    } else {
        container "quay.io/biocontainers/fastqc:0.11.9--0"
    }

    input:
        tuple val(prefix), path (reads) 
	
	output:
        tuple val(prefix), path("*.html"), emit: html
        tuple val(prefix), path("*.zip") , emit: zip
        path  "*details.txt"          , emit: version
        //path "*.log" , emit: fastqc_log


    script:
        software = "${params.software_versions}"
        """
        cmd="fastqc ${reads}"
        echo "version"  >> ${software}
        fastqc --version >> ${software}
        echo "version" >>  ${software}
     
        echo "\${cmd}" >>  ${software}
      
        \${cmd}
        """
}


/**************************************************************************************************************************************************************
* trimmomatic
**************************************************************************************************************************************************************/


process trimmomatic {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/trimmomatic",
        mode: params.publish_dir_mode

	//use container
    conda (params.enable_conda ? "bioconda::trimmomatic" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/trimmomatic:0.39--hdfd78af_2"
    } else {
        container "quay.io/biocontainers/trimmomatic"
    }

    input:
        tuple val(prefix), path (reads) 

    output:
        tuple val(prefix), path("*.trim.fastq")   , emit: trimmed_reads
        tuple val(prefix), path("*.unpaired.trim*"),  optional:true, emit: unpaired_reads
        path  "*details.txt"          , emit: version
        path ".*log" , emit: trimmomatic_log



    script:
        software = "${params.software_versions}"
        fq_1_paired = prefix +'.R1.trim.fastq'
        fq_1_unpaired = prefix +'.R1.unpaired.trim.fastq'
        fq_2_paired = prefix +'.R2.trim.fastq'
        fq_2_unpaired = prefix +'.R2.unpaired.trim.fastq'
        adapter="${params.adapter_file}"

        """
        wget -O ${adapter} https://raw.githubusercontent.com/usadellab/Trimmomatic/main/adapters/${adapter}

        cmd="trimmomatic \
            PE -phred33 \
            ${reads[0]} \
            ${reads[1]} \
            $fq_1_paired \
            $fq_1_unpaired \
            $fq_2_paired \
            $fq_2_unpaired \
            ILLUMINACLIP:${adapter}:2:30:10"

        echo  -n 'trimmomatic '  >> ${software}
        echo "version" >>  ${software}
        trimmomatic -version >> ${software}
        echo "version" >>  ${software}
        echo "\${cmd}" >>  ${software}
        \${cmd}
        """
}

/**************************************************************************************************************************************************************
* unicycler
**************************************************************************************************************************************************************/

process unicycler_short {
    errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/unicycler",
        mode: params.publish_dir_mode

	//use container
    conda (params.enable_conda ? "python=3.7 bioconda::unicycler" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/unicycler:0.5.0--py39h4e691d4_3"
    } else {
        container "quay.io/biocontainers/unicycler"
    }

    input:
        tuple val(prefix), path (reads) 

    output:
        tuple val(prefix), path("${prefix}/assembly.fasta"), emit: scaffolds
        tuple val(prefix), path("${prefix}/assembly.gfa"), emit: gfa
        tuple val(prefix), path("${prefix}"), emit: scaffolds_path
        path  "*details.txt"          , emit: version
        path ".*.log" , emit: unicycler_log


    script:
        software = "${params.software_versions}"
        task.cpus="${params.threads}"
        """
        cmd="unicycler --threads ${task.cpus} -1 ${reads[0]} -2  ${reads[2]} --out ${prefix}" 

        echo "version" >>  ${software}
        unicycler --version >> ${software}
        echo "version" >>  ${software}
        echo "\${cmd}" >>  ${software}
  
        \${cmd}
        """
}

/**************************************************************************************************************************************************************
* busco
**************************************************************************************************************************************************************/

process busco {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3


	publishDir "${params.outdir}/busco",
        mode: params.publish_dir_mode

	//use container
    conda (params.enable_conda ? "bioconda::busco" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/busco%3A5.5.0--pyhdfd78af_0"
    } else {
        container "quay.io/biocontainers/busco"
    }
    input:
        val scaffolds

    output:
        path "assembly_qc/*.txt", emit: summary_file
        val outdir, emit:species_outdir
        path  "*details.txt"          , emit: version
        path ".*.log" , emit: busco_log

    script:
        task.cpus="${params.threads}"
        software = "${params.software_versions}"
        busco_dataset="${params.lineage}"
        """
        cmd="busco -f -i ${scaffolds} -o assembly_qc --mode genome -l ${busco_dataset} -c ${task.cpus}" 
        echo "\${cmd}" >>  ${software}
        busco --version
        \${cmd}
        """
    }

/**************************************************************************************************************************************************************
* checkm 
**************************************************************************************************************************************************************/


process checkm {

 errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/checkm",
        mode: params.publish_dir_mode

//use container
    conda (params.enable_conda ? "bioconda::checkm-genome" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/checkm-genome%3A1.2.2--pyhdfd78af_1"
    } else {
        container "quay.io/biocontainers/checkm-genome"
    }

    input:
        tuple val(prefix), path (scaffolds_path)
         
    output:
        path("${prefix}.tsv")  , emit: checkm_tsv
        path  "*details.txt"   , emit: version
        path ".*.log" , emit: checkm_log


    script:
        task.cpus="${params.threads}"
        software = "${params.software_versions}"
        fasta_ext = 'fasta'
        """
        cmd="checkm  lineage_wf  -t $task.cpus  -f ${prefix}.tsv  --tab_table  --pplacer_threads $task.cpus  -x $fasta_ext  $scaffolds_path  ${prefix}_output" 
        
        \${cmd}

        echo "version" >>  ${software}
        checkm 2>&1 | grep '...:::' | sed 's/.*CheckM v//;s/ .*//'  >>  ${software}
        echo "version" >>  ${software}
        echo "\${cmd}" >>  ${software}
        """
}

/**************************************************************************************************************************************************************
* checkV
**************************************************************************************************************************************************************/


process checkv {
    errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/checkv",
        mode: params.publish_dir_mode

//use container
    conda (params.enable_conda ? "python=3.7 bioconda::checkv" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/checkv%3A1.0.1--pyhdfd78af_0"
    } else {
        container "quay.io/biocontainers/checkv"
    }

    input:
        tuple val(prefix), path (scaffolds)
         
    output:
        path("${prefix}/quality_summary.tsv"), emit: checkv_summary
        path("${prefix}/completeness.tsv"), emit: checkv_completeness
        path("${prefix}/contamination.tsv"), emit: checkv_contamination
        path("${prefix}/complete_genomes.tsv"), emit: checkv_genomes
        path("${prefix}/viruses.fna"), emit: checkv_viruses_fna
        path("${prefix}/proviruses.fna"), emit: checkv_proviruses_fna
        path  "*details.txt"          , emit: version
        path ".*.log" , emit: checkv_log

    script:
        task.cpus="${params.threads}"
        software="${params.software_versions}"
        """
        #ln -s  $baseDir/scripts/db_checkv.sh
        #chmod a+x db_checkv.sh
        checkv download_database ./ || db_checkv.sh

        cmd="checkv end_to_end ${scaffolds} ${prefix} -t ${task.cpus} -d checkv-db*" 
        echo "\${cmd}" >>  ${software}
        
        \${cmd}
        
        echo "version" >>  ${software}
        checkv |head -1| sed 's/: assessing the quality of metagenome-assembled viral genomes//' >>  ${software}
        echo "version" >>  ${software}
        
        echo "\${cmd}" >>  ${software}


        """
}


/**************************************************************************************************************************************************************
* plasclass
**************************************************************************************************************************************************************/

process plasclass {
    errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3
    //errorStrategy 'ignore'

	publishDir "${params.outdir}/plasclass",
        mode: params.publish_dir_mode

    conda (params.enable_conda ? "python=3.7 bioconda::plasclass": null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/plasclass%3A0.1.1--pyhdfd78af_0"
    } else {
        container "quay.io/biocontainers/plasclass"
    }

    input:
        tuple val(prefix), file(scaffolds)

    output:
        path "${prefix}.probs.out" , emit: plasclass_tsv
        path  "*details.txt" , emit: version
        path ".*.log" , emit: plasclass_log

    script:
        task.cpus="${params.threads}"
        software="${params.software_versions}"
        
        """
        
        cmd="classify_fasta.py -f ${scaffolds} -p ${task.cpus} -o ${prefix}.probs.out"
        \${cmd}

        echo "version" >>  ${software}
        echo "plasclass 0.1.1" ${software}
        echo "version" >>  ${software}

        echo "\${cmd}" >>  ${software}

        """

}

/**************************************************************************************************************************************************************
* prokka
**************************************************************************************************************************************************************/


process prokka {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/prokka",
        mode: params.publish_dir_mode

//use container
    conda (params.enable_conda ? "bioconda::prokka" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/prokka%3A1.14.6--pl5321hdfd78af_5"
    } else {
        container "quay.io/biocontainers/prokka"
    }

    input:
        tuple val(prefix), file(contigs_bacteria)
        val (element)

    output:
        tuple val(prefix), path ("${prefix}_${element}_prokka_annotation") , emit: prokka_path
        path  "*details.txt" , emit: version
        path ".*.log" , emit: prokka_log

    script:
        task.cpus="${params.threads}"
        software = "${params.software_versions}"
        """
        cmd="prokka --outdir ${prefix}_${element}_prokka_annotation --prefix ${prefix} --cpus ${task.cpus} ${contigs_bacteria}"
        \${cmd}
  
        echo "version" >>  ${software}
        prokka --version >> ${software}
        echo "version" >>  ${software}
        echo "\${cmd}" >>  ${software}

        """

}


/**************************************************************************************************************************************************************
* pharokka
**************************************************************************************************************************************************************/


process pharokka {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/pharokka",
        mode: params.publish_dir_mode

//use container
    conda (params.enable_conda ? "bioconda::pharokka" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/pharokka%3A1.5.1--pyhdfd78af_0"
    } else {
        container "quay.io/biocontainers/pharokka"
    }

    input:
        tuple val(prefix), file(contigs_phage)

    output:
        tuple val(prefix), path ("${prefix}_phage_pharokka_annotation") , emit: pharokka_path, optional: true
        path  "*details.txt" , emit: version, optional: true
        path ".*.log" , emit: pharokka_log, optional: true

    script:
        task.cpus="${params.threads}"
        software = "${params.software_versions}"
        """
        #ln -s $baseDir/scripts/db_pharokka.sh
        #chmod a+x $baseDir/scripts/db_pharokka.sh
        #install_databases.py -o pharokka_databases || ./$baseDir/scripts/db_pharokka.sh
        install_databases.py -o pharokka_databases
        cmd="pharokka.py -i ${contigs_phage} -o ${prefix}_phage_pharokka_annotation -d pharokka_databases -t ${task.cpus} -meta"
        \${cmd}

        echo "version" >>  ${software}
        pharokka.py --version >> ${software}
        echo "version" >>  ${software}

        echo "\${cmd}" >>  ${software}


        """

}




/**************************************************************************************************************************************************************
* snippy
**************************************************************************************************************************************************************/


process snippy {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

	publishDir "${params.outdir}/snippy",
        mode: params.publish_dir_mode

//use container
    conda (params.enable_conda ? "bioconda::snippy" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/snippy%3A4.6.0--hdfd78af_3"
    } else {
        container "quay.io/biocontainers/snippy"
    }

    input:
        path reference_genome
        tuple val(prefix), path (trimmed_reads)

    output:
        path "${prefix}_snippy " , emit: snippy_path
        path  "*details.txt" , emit: version
        path ".*.log" , emit: snippy_log

    script:
        task.cpus="${params.threads}"
        software = "${params.software_versions}"
    

    """
    cmd="snippy --cpus ${task.cpus} --outdir ${prefix}_snippy --ref $reference_genome --R1 ${trimmed_reads[0]} --R2 ${trimmed_reads[1]}"

    \${cmd}

    echo "version" >>  ${software}
    snippy --version >> ${software}
    echo "version" >>  ${software}

    echo "\${cmd}" >>  ${software} 

    """

}

/**************************************************************************************************************************************************************
* GTDBTK
**************************************************************************************************************************************************************/


process gtdb {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3
    
	publishDir "${params.outdir}/GTDB",
        mode: params.publish_dir_mode

    conda (params.enable_conda ? "bioconda::gtdbtk" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/gtdbtk%3A2.3.2--pyhdfd78af_0"
    } else {
        container "quay.io/biocontainers/gtdbtk"
    }


    input:
        tuple val(prefix), path (chromosome_path)

    output:
        tuple val(prefix), path("gtdbtk.${prefix}.*.summary.tsv")         , emit: gtdbtk_summary
        tuple val(prefix), path("gtdbtk.${prefix}.*.classify.tree.gz")    , emit: gtdbtk_tree, optional: true
        tuple val(prefix), path("gtdbtk.${prefix}.*.markers_summary.tsv") , emit: gtdbtk_markers, optional: true
        tuple val(prefix), path("gtdbtk.${prefix}.*.msa.fasta.gz")        , emit: gtdbtk_msa, optional: true
        tuple val(prefix), path("gtdbtk.${prefix}.*.user_msa.fasta.gz")   , emit: gtdbtk_user_msa, optional: true
        tuple val(prefix), path("gtdbtk.${prefix}.*.filtered.tsv")        , emit: gtdbtk_filtered, optional: true
        tuple val(prefix), path("gtdbtk.${prefix}.failed_genomes.tsv")    , emit: gtdbtk_failed, optional: true
        tuple val(prefix), path("gtdbtk.${prefix}.warnings.log")          , emit: gtdbtk_warnings,optional: true
        path  "*details.txt" , emit: version,optional: true
        path ".*.log" , emit: gtdbtk_log,optional: true

    script:
    task.cpus="${params.threads}"
    software = "${params.software_versions}"
   
    """
   #while true; do
    #    wget -T 15 -c https://data.gtdb.ecogenomic.org/releases/release214/214.0/auxillary_files/gtdbtk_r214_data.tar.gz && break
    #done
    
    #tar -xvzf gtdbtk_r214_data.tar.gz
    #GTDBTK_DATA_PATH="./release214"

    #download-db.sh
    cmd="gtdbtk classify_wf --genome_dir ${chromosome_path} --prefix gtdbtk.${prefix} --out_dir ${prefix}_gtdbtk_classification --cpus ${task.cpus} --skip_ani_screen"
    
    #\${cmd}
    touch gtdbtk.${prefix}.*.summary.tsv
    echo "version" >>  ${software}
    gtdbtk --version >> ${software}
    echo "version" >>  ${software}

    echo "\${cmd}" >>  ${software} 
    """

}

/**************************************************************************************************************************************************************
* split assembly
**************************************************************************************************************************************************************/

        
process split_assembly {
	publishDir "${params.outdir}/splitting_assemblies",
        mode: params.publish_dir_mode

  conda (params.enable_conda ? "bioconda::samtools" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/samtools%3A1.9--h91753b0_8"
    } else {
        container "quay.io/biocontainers/samtools"
    }


    input:
        tuple val(prefix), path (scaffolds_path)
        path (plasclass_tsv)
        path (checkv_summary)
    
    output:
        tuple val(prefix), path("${prefix}_de_novoassembly.fasta"), emit: novoassembly_path, optional: true
        tuple val(prefix), path("${prefix}_chromosome.fasta"), emit: chromosome_path, optional: true
        tuple val(prefix), path("${prefix}_plasmid.fasta"), emit: plasmid_path, optional: true
        tuple val(prefix), path("${prefix}_phage.fasta"), emit: phage_path, optional: true
        
    script:

        """
        # all contigs 
        grep ">" ${scaffolds_path} |cut -d " " -f1|sed 's/>//' >all_contigs.txt

        #plasmid contigs
        awk 'BEGIN{OFS="\\t"} \$2 >= 0.8 {print \$1}' ${plasclass_tsv} >plasmid_contigs.txt

        #phage contigs
        grep "Yes" ${checkv_summary}| cut -f1 >phage_contigs.txt

        #extrachr contigs
        cat plasmid_contigs.txt phage_contigs.txt >extrachr.txt
        
        #chromosome contigs
        grep -vwf extrachr.txt all_contigs.txt >chromosome_contigs.txt

        #extract contigs
        xargs samtools faidx ${scaffolds_path} < chromosome_contigs.txt > ${prefix}_chromosome.fasta
        xargs samtools faidx ${scaffolds_path} < plasmid_contigs.txt > ${prefix}_plasmid.fasta
        xargs samtools faidx ${scaffolds_path} < phage_contigs.txt > ${prefix}_tmp_phage.fasta
        awk 'BEGIN { FS=OFS=" " } /^>/ { print \$1"_phage"; next }1' ${prefix}_tmp_phage.fasta > ${prefix}_phage.fasta

        
        ln -s ${scaffolds_path} ${prefix}_de_novoassembly.fasta

        """



}


/**************************************************************************************************************************************************************
* Prodigal
**************************************************************************************************************************************************************/
process prodigal {
     errorStrategy { sleep(Math.pow(2, task.attempt) * 200 as long); return 'retry' }
    maxRetries 3

  	publishDir "${params.outdir}/prodigal",
        mode: params.publish_dir_mode

  conda (params.enable_conda ? "bioconda::prodigal" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "https://depot.galaxyproject.org/singularity/prodigal%3A2.60--1"
    } else {
        container "quay.io/biocontainers/prodigal"
    }

    input:
    tuple val(prefix), path(contigs)


    output:
    tuple val(prefix), path("${prefix}_prodigal"), emit: gene_annotations
    tuple val(prefix), path("${prefix}_genes.fasta"), emit: nucleotide_fasta
    tuple val(prefix), path("${prefix}_genes.faa"), emit: amino_acid_fasta
    path  "*details.txt" , emit: version
    path ".*.log" , emit: prodigal_log 


    script:
 
    """
    
    cmd="prodigal -i ${contig}  -o ${prefix}_prodigal -a ${prefix}_genes.faa -d ${prefix}_genes.fasta -f gff -q"

    \${cmd}

    echo "version" >>  ${software}
    prodigal -v 2>&1 | sed -n 's/Prodigal V\\(.*\\):.*/\\1/p' >> ${software}
    echo "version" >>  ${software}

    echo "\${cmd}" >>  ${software} 

    """
}

/**************************************************************************************************************************************************************
* Assembly2Gene
**************************************************************************************************************************************************************/


/**************************************************************************************************************************************************************
* Report
**************************************************************************************************************************************************************/



process report{

    publishDir "${params.outdir}",
        mode: params.publish_dir_mode

    //errorStrategy 'ignore'
      conda (params.enable_conda ? "r-base r-rmarkdown" : null)
    if (workflow.containerEngine == 'singularity' && !params.singularity_pull_docker_container) {
        container "rocker/tidyverse"
        //container "https://depot.galaxyproject.org/singularity/r-rmarkdown%3A0.9.5--0"
        //// container "https://depot.galaxyproject.org/singularity/r-markdown%3A0.8--r3.4.1_1"
    } else {
        container "quay.io/biocontainers/R"
    }

    input:
        tuple val(prefix), path (fastqc_html) 
        tuple val(prefix), path (fastqc_trim_html)
        tuple val(prefix), path (novoassembly_path)
        tuple val(prefix), path (chromosome_path)
        tuple val(prefix), path (plasmid_path)
        tuple val(prefix), path (phage_path)
        path (checkm_tsv)
        tuple val(prefix), path (prokka_denovo_path)
        tuple val(prefix), path (prokka_chr_path)
        tuple val(prefix), path (prokka_plasmid_path)
        tuple val(prefix), path (pharokka_path)
        path (plasmid_class)
        path (phage_class)
        path (snippy_path)
        tuple val(prefix), path (gtdbtk_summary)
        //tuple val(prefix), path (assembly2gene_table)
        //tuple val(prefix), path (assembly2gene_aligments)
        //tuple val(prefix), path (assembly2gene_peptides)
  
    output:
        tuple val(prefix), path("${prefix}_ProkGenomics_report.html"), emit: report_path


    script:
        task.cpus="${params.threads}"
        software= "${params.software_versions}"
        version= "${params.version}"
        github="${params.github}"
        report_template="${params.report_template}"
        Rrender="${params.Rrender}"


        """    
        echo "Run Rscript in one line in the container"  
        ln -s ${params.report_template}
        ln -s ${params.logo}
        ln -s ${params.Rrender}

        #FLAGS=(--archive --exclude="foo bar.txt")
 
      
         cmd1=(fastqc_version=try(system(paste0("if [ -s ",${params.outdir},"/fastqc/software_details.txt ];then sed -n '/version/,/version/{ /version/!p }' ",${params.outdir},"/fastqc/software_details.txt; fi"),intern = TRUE),silent=TRUE))
        Rscript -e \${cmd1[\@]}\\
                -e  "print(fastqc_version)"

     

        #Rscript report_render.R ${params.report_template} ${params.outdir} ${prefix} ${version} ${github} ${params.outdir}/fastqc/${fastqc_html[0]} ${params.outdir}/fastqc/${fastqc_html[1]} ${params.outdir}/fastqc/${fastqc_trim_html[0]} ${params.outdir}/fastqc/${fastqc_trim_html[2]} ${params.outdir}/unicycler/${novoassembly_path} ${params.outdir}/splitting_assemblies/${chromosome_path} ${params.outdir}/splitting_assemblies/${plasmid_path} ${params.outdir}/splitting_assemblies/${phage_path} ${params.outdir}/checkm/${checkm_tsv} ${params.outdir}/prokka/${prokka_denovo_path} ${params.outdir}/prokka/${prokka_chr_path} ${params.outdir}/prokka/${prokka_plasmid_path} ${params.outdir}/pharokka/${pharokka_path} ${params.outdir}/plasclass/${plasmid_class} ${params.outdir}/checkv/${phage_class}
                                  
        """



}

// check the version 
//sed -n '/version/, /version/{ /version/!p }' software_details.txt 

/*process Deleting_work_directory{
    input:
    tuple val(name), path(read) from Variant_calling   //here I gave the input from last process.

    output:
    path CleanUp, optional: true

    script:
    """
    rm -rf /path/of/the/work directory/work
    rm -rf /path/of/the/Hidden Log files/.nextflow*
    """
}*/